<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>资源加载异常</title>
</head>
<body>
<script>
    //3.事件捕获
    //Error事件在事件捕获阶段进行捕获,注意下面设置成true，如果设置成false该方法不生效
    window.addEventListener('error', function (e) {
        console.log('捕获', e);
    }, true);

</script>
</body>
<!--1.object.onerror-->

<!--img错误在此捕获一次，但也会被window.addEventListener('error')捕获-->
<img src="myimage.gif"
     onerror="console.log('为自img的onerror回调')"/>
<script src="//badu.com/test.js" charset="utf-8"></script>
<script>

//    2

    //获取所有已加载资源，与标签获取的资源对比
//    performance.getEntries(item => console.log(item.name))
//    doc.getElementsByTagName('xx')

    //错误上报
    //AJAX
    //利用图片src请求上报，比AJAX简单得多
    //    (new Image()).src = 'http://baidu.com/tesjk?r=tksjk';//后面跟你想上报的信息

    throw new Error("出错了！");


//https://www.chrisyue.com/what-the-hell-is-crossorigin-attribute-in-html-script-tag.html
//    跨域脚本错误监控

//引入跨域的脚本（比如用了 apis.google.com 上的库文件），如果这个脚本有错误，因为浏览器的限制（根本原因是协议的规定），是拿不到错误信息的。
// 当本地尝试使用 window.onerror 去记录脚本的错误时，跨域脚本的错误只会返回 Script error。

//HTML5 新的规定，可以允许本地获取到跨域脚本的错误信息
// 有两个条件：一是跨域脚本的服务器必须通过 Access-Controll-Allow-Origin 头信息允许当前域名可以获取错误信息
// 二是当前域名的 script 标签也必须指明 src 属性指定的地址是支持跨域的地址，也就是 crossorigin 属性。即开启跨域检测

//http://blog.csdn.net/renfufei/article/details/51675148?
</script>
</html>