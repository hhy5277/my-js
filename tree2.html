<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>根据叶子节点构建树</title>
</head>
<body>
<script>
const treeData = {
    id: 1,
    name: '1层',
    players: [],
    children: [
        {
            id: 2,
            name: '2层',
            players: [],
            children: [
                {
                    id: 2,
                    name: '3层',
                    players: ['A', 'B'],
                },
                {
                    id: 3,
                    name: '3层',
                    players: ['C', 'D'],
                }
            ]
        },
        {
            id: 3,
            name: '2层',
            players: [],
            children: [
                {
                    id: 2,
                    name: '3层',
                    players: ['E', 'F'],
                },
                {
                    id: 3,
                    name: '3层',
                    players: ['G', 'H'],
                }
            ]
        }
    ]
};

let teams = [];

// 深度遍历
function traverse(node) {
    if (node.children) {
        node.children.forEach((child) => {
            traverse(child);
        });
    } else {
        teams = teams.concat(node.players);
    }
}

traverse(treeData);
console.log(teams);

function getTreeDepth(leavesCount) {
    // 求以2为底的对数 再加上1 即树的深度
    return Math.log(leavesCount) / Math.LN2 + 1;
}

function createTree(leaves, symbol) {
    const treeDepth = getTreeDepth(leaves.length);
    const root = { name: symbol, depth: 1 };// depth记录当前节点所在层次
    const queue = [root];
    let node = null;
    let leavesIdx = 0; // 叶子节点指针

    while (queue.length) {// 广度遍历
        // 从队头弹出节点
        node = queue.shift();

        const currentDepth = node.depth;
        const nextDepth = currentDepth + 1;

        if (currentDepth === treeDepth) {// 到叶子层结束
            return root;
        }

        let leftChild = null;
        let rightChild = null;

        if (currentDepth < treeDepth - 1) {
            leftChild = { name: symbol, depth: nextDepth };
            rightChild = { name: symbol, depth: nextDepth };
        } else {// 到叶子层的上一层，则添加叶子为孩子
            leftChild = { name: leaves[leavesIdx], depth: nextDepth };
            leavesIdx += 1; // 移动叶子指针
            rightChild = { name: leaves[leavesIdx], depth: nextDepth };
            leavesIdx += 1;
        }

        queue.push(leftChild);
        queue.push(rightChild);
        node.children = [leftChild, rightChild];
    }
}

const root = createTree(teams, '?');
console.log(root);
</script>
</body>
</html>
