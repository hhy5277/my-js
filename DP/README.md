## 原则
### 开放-封闭 原则

### 单例模式
- 单例模式的核心
    1. 确保只有一个实例
    2. 提供全局访问
- 实战
    - createScript
    - createXhr
    
### 装饰者模式
装饰者(decorator)模式也称为包装器(wrapper)模式

从功能上而言，decorator能很好地描述这个模式，但从结构上看，wrapper的说法更加贴切。
装饰者模式将一个对象嵌入另一个对象之中，`实际上相当于这个对象被另一个对象包装起来，形成一条包装链。`
请求随着这条链依次传递到所有对象，每个对象都有处理这个请求的机会

- 实战
    - 用户操作记录上报 p217
    - 动态添加参数 p218
    - ajax token 解耦 p219
    - 表单验证解耦

#### 注意
因为通过Function.property.before | after 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，
那么这些属性会丢失。比如

````js
    var func = function() {
      console.log(1);
    };
    func.a = 'a';
    
    func.after = function() {
        console.log(2);  
    };
    console.log(func.a);// undefined
````

### 策略模式
思想：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

策略模式利用`组合、委托、多态`等技术和思想，可有效地`避免多重条件选择语句`

    - 组合：定义一系统算法，并封装它们？？
    - 委托：context接受开发者的请求，随后委托给某一个策略类计算
    - 多态：不同策略实现共同的接口
    
### 命令模式

- 智能命令

    command对象的execute方法里保存一个接收者来负责真正执行开发者的请求。这种模式的好处是请求发起者和请求接收者之间尽可能地得到也解耦
    
- 傻瓜命令
    
    command对象的execute方法直接执行请求，不需要调用接收者执行
    
应用

- 记录命令，录像重播

### 组合模式
组合模式的树型结构容易让人误以为组合对象和叶子对象是父子关系，这是不正确的。

组合模式是一种HAS-A（聚合）的关系，而还是IS-A。组合对象包含一组叶子对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶子对象，
它们能够合作的关键是拥有`相同的接口`   --p147

适用场景：希望统一对待树中的所有对象，处理树时能够忽略叶子对象与组合对象的区别
    
### 职责链模式

职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率？？