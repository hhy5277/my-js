## 前置概念
- 执行环境(execution context，有时也称为"环境")定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
- 每个执行环境都有一个与之关联的变量对象(variable object,简写VO)，环境中定义的所有变量和函数都保存在这个VO。
- 在代码中无法访问到VO，但解析器在处理数据时会在后台使用它。

## 全局执行环境
- 全局执行环境是最外围的一个执行环境。
- web浏览器中，全局执行环境被认为是window对象(注意这里说的，执行环境是一个对象，个人更倾向于理解为window对象是全局执行环境对应的VO)
- 全局变量和函数都作为window对象的属性和方法创建
- 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之被销毁(注意是所有变量和函数定义，也就是VO被销毁)
- 全局执行环境直到应用程序退出--例如关闭网页或浏览器时才会被销毁。

### 闭包
- 在另一个函数内部定义的函数会将包含它的外部函数的Scope属性当作到它的[[scope]]

##延长作用域链
- with
- try/catch
    ````
    Scope = withObject|catchObject + AO|VO + [[Scope]]
    
    try {
      ...
    } catch (ex) {
      alert(ex);
    }
    
    //作用域链修改为如下所示：
    
    var catchObject = {
      ex: 
    };
     
    Scope = catchObject + AO|VO + [[Scope]]
    ````

## 函数的生命周期
- 创建 
  - 创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在函数的[[scope]]属性中。
- 执行
  - 当程序执行到某个函数时，会创建该函数的执行环境，然后将该环境推入一个环境栈中
  - 进入执行环境，进行AO初始化，AO初始化内容
  >xxxxxxxxxxxxxxxxxx arguments对象，及参数变量，VD,FD。。。
  - 然后通过复制函数的[[scope]]属性中的对象+函数的AO，构建起函数执行环境的作用域链即Scope属性。
- 销毁
  - 当一个函数返回一个函数时，该执行环境的的作用域链会被销毁
  - 但它的活动对象会由于返回函数的作用域连引用，会保留在内存中。直到匿名函数被销毁后，外部函数的活动对象才会被销毁。
  - 函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。